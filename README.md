# hikaru

A deployment tool for kubernetes. 100 internets if you get the reference. 1000 internets if you get why.

# What It Does - Automating Continuous Delivery

hikaru was built specifically to make it easy to deploy and maintain kubernetes clusters.

 * Initial deployment
 * Re-deployment/Updates
 * Removal/clean-up

# Complimentary Tooling

hikaru assumes you're working with [McGonagall](https://github.com/npm/mcgonagall) style cluster specifications. You'll get the most mileage out of it by adopting [Dockyard](https://github.com/npm/dockyard) or at least using a compatible tagging approach (see: [buildgoggles](https://www.npmjs.com/package/buildgoggles)) because of how hikaru infers metadata about Kubernetes resources based on Docker images.

# Modes

hikaru tries to make life as easy as possible by providing 3 possible models for interaction:

 * an HTTP API to expose common use cases
 * a CLI for interacting with Kubernetes clusters directly
 * programmatically via the lib

# Continuous Delivery

hikaru receives an API call (ideally, via Web Hook) to evaluate a Docker image. It determines which Deployments would qualify for an upgrade based on the image's tag. For each Deployment that qualifies, hikaru will perform rolling upgrades using the image. Limitations to this behavior can be introduced via metadata on the Kubernetes manifests themselves.

In practice, this is simple to use and requires very little effort. hikaru is able to perform automated rolling upgrades out of the gate with no additional metadata on the manifests. If you want finer tuned controls, your team will have to adopt some simple labeling conventions so that hikaru will be able to determine when to perform upgrades.

## How hikaru Filters By Manifest Metadata Labels 

The following labels act like filters that hikaru will use against the image metadata it determines from the tag. If these labels are present under the manifest's `spec.metadata.labels` then they will be used to determine whether a new image is compatible with the manifest.

This allows you to filter out builds from owners, branches, etc. that you don't want hikaru to deploy over a certain environment/manifest:

 * `branch` - limit deployments to a specific branch, omission means _any_ branch
 * `version` - provide version restrictions, only allow new builds of the same version
 * `commit` - **!caution!** locks the deployment to a specific commit

## How hikaru Reads The Tag

hikaru understands how to process the following tag styles:

 * if the build is from the master branch
 	* `latest` - the latest build from our master branch
 	* `major` - the major part of the semantic version
 	* `major.minor` - the major and minor parts of the semantic version
 * `{branch}_{version}_{build}_{commit-slug}` - for builds generated from 
 * A tag generated by builgGoggles could include: `{owner}_{branch}_{version}_{build}_{commit-slug}` to allow for builds of forks and builds where multiple images are generated from a single repo.

hikaru will attempt to filter out additional tag noise and also treat any `-{label}` following a version number as a pre-release.

hikaru will determine or infer 6 pieces of information about a Docker image:

 * Docker image (two parts)
     * repo: if it's empty, it's an official repo, it's set to the image name
     * name: the actual image name
     * examples: 
         * `redis` - image = `redis/redis`
         * `mhart/alpine-node` - image = `mhart/alpine-node`
 * Owner
 	* hikaru only parses this out of the first position of a tag with 5+ elements
 	* if not specified, this is inferred from the image's owner name
  * when missing entirely, this is assumed to be an `official` image
 	* examples:
 		* `npm/app:arobson_master_1.0.1_10_abcd1234` - owner = `arobson`
 		* `npm/app:latest` - owner = `npm`
    * `nginx:13-alpine` - owner = `official`
 * Branch
 	* parsed from the front of tags with 4 elements or
 	* conditionally from larger tags depending on element count
 	* if not specified, hikaru infers `master`
 	* examples:
 		* `npm/app:arobson_test_1.0.1_10_abcd1234` - branch = `test`
 		* `npm/app:now-with-more-stuff_1.0.1_10_abcd1234` - branch = `now-with-more-stuff`
 		* `npm/app:1.0` - branch = `master`
 		* `npm/app:1` - branch = `master`
 		* `npm/app:latest` - branch = `master`
 * Version
 	* hikaru has a nuanced reading of versioning
 	* its goal is to determine if an image would be considered a "newer" version of an existing version
 	* easiest to understand by example:
 		* `npm/app:latest` - `latest`
 		* `npm/app:1` - `latest 1.x.x`
 		* `npm/app:1.1` - `latest 1.1.x`
 		* `npm/app:arobson_test_1.0.1_10_abcd1234` - `1.0.1`
 * Build Number
 	* unlike other values, hikaru does not infer a build when its not in the tag
 	* it shows when one image is newer than another
 	* always comes immediately after the version in a tag
 * Commit SHA/Slug
 	* like the build number, never inferred
 	* only valuable as a `lock` when testing development builds
 	* always 8 characters at the end of the tag

# HTTP Service

## API

### `POST /api/image/{dockerImage}`

Responds with a list of deployments which will receive rolling update calls with the new Docker image.

### `GET /api/image/{repository}/{image}
### `GET /api/image/{registry}/{repository}/{image}

Responds with a list of namespaces and services presently using the image. 

Useful to see which services may be eligible for upgrade on the image (depends entirely on the tag).

### `POST /api/job`

Based on the content type, you can supply `application/json` or `application/yaml` as the job definition

## Environment Variables
When running as a service, all configuration is driven by environment variables:

 * `K8S-URL`
 * `K8S-HOST`
 * `K8S-TOKEN`
 * `K8S-CA`
 * `K8S-CERT`
 * `K8S-KEY`
 * `K8S-USERNAME`
 * `K8S-PASSWORD`
